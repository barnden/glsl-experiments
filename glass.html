<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raymarcher</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;

            background: #16161D;
            height: 100%;
            width: 100%;

            display: flex;

            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <canvas id="marcher" width="900" height="900"></canvas>
    <script type="text/x-fragment-shader" id="discard">#version 300 es
precision highp float;in vec3 i_Position;void main(){gl_Position=vec4(i_Position,1.);}</script>
    <script type="text/x-fragment-shader" id="frag">
        #version 300 es
        precision highp float;

        uniform vec2 u_Resolution;
        uniform vec4 u_Mouse;
        uniform float u_Time;
        uniform int u_Frame;

        out vec4 o_FragColor;

        // Consts
        #define MAX_ITER 100
        #define MAX_TIME 20.
        #define MAX_RFLEC_RECURSE_DEPTH 4
        #define MAX_RFRAC_RECURSE_DEPTH 4
        #define EPSILON  0.0001
        #define PI 3.141592653
        #define TAU 6.283185307

        // Raymarching/tracing stuff
        struct Ray {
            vec3 origin;
            vec3 direction;
            bool is_reflection;
            bool is_refraction;
            bool invert_ior; // false if ray passing into object, true otherwise
        };

        struct Light {
            vec3 origin;
            vec3 color;
        };

        struct Material {
            vec3 ka; // color of ambient
            vec3 kd; // color of diffuse
            vec3 ks; // color of specular
            vec3 kr; // color of reflection
            vec3 kt; // color of refraction
            float m; // roughness (beckmann)
            float ior; // refract idx
        };

        struct Record {
            bool hit;
            vec3 point;
            vec3 normal;
            Material material;
        };

        mat3 get_lookat(vec3 eye, vec3 lookat, float r)
        {
            vec3 w = normalize(lookat - eye);
            vec3 u = normalize(cross(vec3(cos(r), sin(r), 0.), w));

            return mat3(cross(u, w), u, w);
        }

        Ray primaryRay(vec3 eye, vec3 ta, float fovy, float focalDistance)
        {
            // Perspective
            mat3 lookat = get_lookat(eye, ta, 0.);
            vec2 uv = (2. * gl_FragCoord.xy - u_Resolution.xy) / u_Resolution.xy * tan(radians(fovy) / 2.);

            return Ray(
                eye,
                normalize(lookat * vec3(uv, focalDistance)),
                false,
                false,
                false
            );
        }

        // SDF Primitives
        float sd_sphere(vec3 p, float r) { return length(p) - r; }
        float sd_box(vec3 p, vec3 b)
        {
            vec3 q = abs(p) - b;
            return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);
        }

        // SDF Operations
        float op_round(float d, float r) { return d - r; }

        // Transform
        vec3 op_tx(vec3 pos, mat4 t) { return (inverse(t) * vec4(pos, 1.)).xyz; }

        // Rotation
        vec3 op_rz(vec3 pos, float deg)
        {
            mat4 rot = mat4(
                vec4(cos(deg), -sin(deg), 0., 0.),
                vec4(sin(deg), cos(deg),  0., 0.),
                vec4(0., 0., 1., 0.),
                vec4(0., 0., 0., 1.)
            );

            return op_tx(pos, rot);
        }

        vec3 op_ry(vec3 pos, float deg)
        {
            mat4 rot = mat4(
                vec4(cos(deg), 0., sin(deg), 0.),
                vec4(0., 1., 0., 0.),
                vec4(-sin(deg), 0., cos(deg), 0.),
                vec4(0., 0., 0., 1.)
            );

            return op_tx(pos, rot);
        }

        vec3 op_rx(vec3 pos, float deg)
        {
            mat4 rot = mat4(
                vec4(1., 0., 0., 0.),
                vec4(0., cos(deg), -sin(deg), 0.),
                vec4(0., sin(deg), cos(deg), 0.),
                vec4(0., 0., 0., 1.)
            );

            return op_tx(pos, rot);
        }

        void emplace(inout vec2 rec, float d, float idx) { if (rec.x > d) rec = vec2(d, idx); }

        vec2 sd_map(vec3 p)
        {
            vec2 angle = TAU * mix(0. * vec2(cos(u_Time / 5.), sin(u_Time / 7.)) + vec2(.122, .112), u_Mouse.z * (u_Mouse.yx / u_Resolution.yx), u_Mouse.z);
            vec2 rec = vec2(MAX_TIME, 1.);

            rec.x = dot(p + vec3(0., 3., 0.), normalize(vec3(0., 1., 1.)));
            emplace(rec, sd_sphere(p + vec3(-.5, .5, .125), .125), 3.);

            p = op_rx(op_ry(p, -angle.y), angle.x);

            float sphere = sd_sphere(p, .3);
            float cube = sd_box(p, vec3(.25));
            float smcube = op_round(sd_box(p, vec3(.18)), .05);

            //emplace(rec, mix(cube, sphere, smoothstep(0., 1., cos(.5 * u_Time))), 2.);
            emplace(rec, cube, 2.);


            return rec;
        }

        vec3 get_normal(vec3 p)
        {
            vec2 e = vec2(1., -1.) * EPSILON;
            return normalize(e.xyy * sd_map(p + e.xyy).x + e.yyx * sd_map(p + e.yyx).x + e.yxy * sd_map(p + e.yxy).x + e.xxx * sd_map(p + e.xxx).x);
        }

        Material get_material(float idx)
        {
            if (idx > 2.5)
                return Material(
                    vec3(.1),
                    vec3(0.),
                    vec3(0.),
                    vec3(.8),
                    vec3(0.),
                    1.,
                    2.5
                );

            if (idx > 1.5)
                return Material(
                        vec3(.1),
                        vec3(.53, .23, .43),
                        vec3(.8),
                        vec3(.8),
                        vec3(.1),
                        .015,
                        1.562 // approx ior for glass
                    );

            if (idx > 0.5)
                return Material(
                    vec3(.12),
                    vec3(.2),
                    vec3(0.),
                    vec3(0.),
                    vec3(0.),
                    1.,
                    2.5
                );

            return Material(vec3(0.), vec3(0.), vec3(0.), vec3(0.), vec3(0.), 0., 1.);
        }

        Record cast_ray(Ray ray)
        {
            float t = EPSILON;
            float midx = 0.;
            vec3 p;
            for (int i = 0; i < MAX_ITER && t < MAX_TIME; i++)
            {
                p = ray.origin + ray.direction * t;
                vec2 h = sd_map(p);
                midx = h.y;

                if (abs(h.x) < EPSILON)
                    break;

                t += h.x;
            }

            if (t < MAX_TIME)
                return Record(true, p, get_normal(p), get_material(midx));

            return Record(false, vec3(0.), vec3(0.), get_material(0.));
        }

        // Stuff for specular highlights
        // Fresnel approx.
        float schlick(float r0, float c) { return r0 + (1. - r0) * pow(1. - c, 5.); }

        float beckmann(float HN, float m)
        {
            float cos2 = HN * HN;
            float tan2 = (cos2 - 1.) / cos2;
            float m2 = m * m;

            return exp(tan2 / m2) / (PI * m2 * cos2 * cos2);
        }

        float cook_torrance(vec3 L, vec3 N, vec3 E, float ior1, float ior2, float m)
        {
            vec3 H = normalize(L + E);

            float EN = dot(E, N);
            float LN = dot(L, N);
            float HN = max(EPSILON, dot(H, N));

            float c = 2. * HN / dot(E, H);
            float G = min(1., min(c * EN, c * LN));

            float D = beckmann(HN, m);

            float r0 = pow((ior1 - ior2) / (ior1 + ior2), 2.);
            float F = schlick(r0, EN);

            return D * F * G / (PI * EN * LN);
        }

        const Light sun = Light(vec3(-1.25, 1.2, 2.), vec3(.64, .59, .54));

        vec3 compute_ray_color(Ray ray)
        {
            Record rec = cast_ray(ray);

            if (!rec.hit) // return sky
                return pow(vec3(.0833, .55, .75) - .5 * ray.direction.y, vec3(.4545));

            vec3 col = vec3(0.);
            vec3 rfl = rec.material.kr;

            for (int i = 0; i < 1; i++) {
                if (!rec.hit)
                    break;

                vec3 local_color = rec.material.ka;

                vec3 L = sun.origin - rec.point;
                vec3 N = rec.normal;

                Record srec = cast_ray(Ray(rec.point + N * EPSILON, normalize(L), false, false, false));
                if (srec.hit) {
                    col += 2.5 * rec.material.kd * srec.material.ka;
                    break;
                }

                vec3 E = normalize(ray.origin - rec.point);
                float LN = dot(L, N);

                vec3 diffuse = rec.material.kd * max(0., LN);
                vec3 specular = rec.material.ks * cook_torrance(L, N, E, rec.material.ior, 1., rec.material.m);
                local_color += sun.color * (diffuse + specular);

                if (ray.is_refraction)
                    local_color *= rec.material.kt + vec3(1.,0.,0.);

                if (ray.is_reflection)
                    local_color *= rfl;

                col += local_color;

                if (length(rec.material.kr) < EPSILON)
                    break;

                //vec3 refraction = refract(L, N, ray.invert_ior ? 1. / rec.material.ior : rec.material.ior);
                //ray = Ray(rec.point + N * EPSILON, normalize(refraction), false, true, true);
                rfl = rec.material.kr;
                ray = Ray(rec.point + N * EPSILON, normalize(reflect(L, N)), true, false, false);
                rec = cast_ray(ray);
            }

            return col;
        }

        void main()
        {
            vec3 lookat = vec3(0., 0., -1.);
            vec3 eye = vec3(0., 0., 1.);
            Ray ray = primaryRay(eye, lookat, 90., 1.5);

            o_FragColor = vec4(compute_ray_color(ray), 1.);
        }
    </script>
    <script type="module" src="marcher.js"></script>
</body>

</html>
